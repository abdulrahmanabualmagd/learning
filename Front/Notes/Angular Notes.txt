[Framework/Library]
      - library is a collection of codes written for solving a specific problem like ( React / JQuery / )
      - framework is a collection of libraries only import what we want to use (Angular) 
            - Component-Based Application
            - single page application (routing)
            
[Development Enviroment Installation] 
      - install node.js                         // to use the node package manger (npm) to install the required packages
      - npm install -g typescript               // Installing Typescript Globally, Because Angular use TypeScript for buil the application      
      - npm install -g @angular/cli             // Installing Angular globally
            - ng new projectName                // Create new Angular project and initialize its files
                  - any flags set while creating the project applied over the entire project
                  - ng serve -o                 // Starts your development server to host the Angular project with option -o to open the server  

      - ng generate module        [name]        // group related code and comopnents
      - ng generate component     [name]        // angular component with its associated files (HTML, TS, CSS)
            - --inline-template --inline-style  // These flags used to make the style and template inline (creates only the ts file and write CSS and HTML on the main file) 
            - --standalone --flat               // flat used to create it on the current folder and (standalone) means that it does not require a declaration in NgModule
            - standalone component   => explicitly manage their own dependencies
      - ng generate service       [name]        // Used for encapsulating and organizing business logic, data retrieval or other operations that can be shared (across components)
      - ng generate directive     [name]        // Used to extend and enhance the behavior of HTML elements, attributes, and even CSS
      - ng generate class         [name]        // Generate Importable Class
      - ng generate enum          [name]        // Generate Importable Function
      - ng generate pipe          [name]        // Used to Transform the data before Displaying it like <p>{{data | json}}</p>
      - ng generate interface     [name]        // Generate Importable Interface
      - ng generate guard         [name]        // Used to control whether a route can be activated or not, based on certain conditions
      - ng generate resolver      [name]        // Used to ensure that the data required for a component is avialable before the component is activated
      - ng generate interceptor   [name]        // Used to intercept and modify HTTP request or responses globally before they reach the server of the application's comopnents ( Add Headers, Loggin, Error Handling )
      - ng generate library       [name]        // Packages of resuable code that can be shared on distributed across multiple projects, contain (components, services, directives,)
      
      - --skip-tests                            // Skip creating testing file .spec for the created element
      - --skip-import                           // Skip importing and adding the created element to the app.module (NgModule)

[Create Multible Projects]
      - ng new my-workspace --no-create-application               // this flag to create the workspace without any project
      - ng generate application [name]    --skip-tests            // Create new project inside the workspace in projects/ directory
            --skip-tests => will make all things generated on that project without the test file (.spec)
      - ng generate library [name]                                // Generate library that may have components, services, modules, directives, and pipes
      
      
[Angular] is an Open Source framework 
      - Component Based Application [ Aside / Nav / body / footer / ] => (Shared / Core)
      
[Project Sharing]
      - when sharing the projcet we don't share all the files include node modules because it's too large in size 
            - we share the project without that file and the receiver and in the package.json and package.lock.json both contains modules and modules dependencies 
            - so the receiver by running # npm install => it will install all the modules automatically from package.json

[Angular Directory Structure] ------------------------------------------------------------------

      [Workspace Files]       => ng new MyWorkSpace --no-create-application                              
      |
      |-----[Workspace Configuration Files]
      |     |
      |     |-----[.editorconfig]
      |     |           - Configuration for code editors
      |     |     
      |     |-----[.gitignore]
      |     |           - Specifies intentionally untracked files that Git should ignore.
      |     |           
      |     |-----[README.md]
      |     |           - Introductory documentation for the root application.
      |     |     
      |     |-----[angular.json]
      |     |           - CLI configuration defaults for all projects in the workspace
      |     |     
      |     |-----[package.json]          => (npm)
      |     |           - Configures npm package dependencies that are available to all projects in the workspace
      |     |           
      |     |-----[package-lock.json]     => (npm)
      |     |           - Provides version information for all packages installed into node_modules by the npm client
      |     |           
      |     |-----[tsconfig.json]
      |                 - The base TypeScript configuration for projects in the workspace
      |
      |
      |-----[Projects Files (All)]        => ng generate application MyProject1
            |
            |-----[Project Files]
            |     |
            |     |-----[Project Application Configuration Files]
            |     |     |
            |     |     |-------[tsconfig.app.json]
            |     |     |           - Extends the settings from the [tsconfig.json] 
            |     |     |           - Specified for the Current Angular Proejct Application
            |     |     |   
            |     |     |-------[tsconfig.spec.json]
            |     |                 - Extends the settings from the [tsconfig.jcon]
            |     |                 - Specified for Typescript Unit Tests configuration
            |     |     
            |     |-----[Project Application source files]    [src/]
            |           |     
            |           |-----[Application Files]     [app/] 
            |           |     |
            |           |     |     - Contains the component files in which your application logic and data are defined
            |           |     |   
            |           |     |-----[app-routing.module.ts]
            |           |     |           - Setting up the routing configuration for the Angular Project
            |           |     |     
            |           |     |-----[app.config.ts]
            |           |     |           - Defines the application config logic that tells Angular how to assemble the application
            |           |     |           - As we add more providers to the app, they must be declared here
            |           |     |           
            |           |     |-----[app.component.ts]      (root component)
            |           |     |           - Define the logic for the application's root component (AppComponent)
            |           |     |     
            |           |     |-----[app.component.html]    (root component)
            |           |     |           - Defines the HTML template associated with the root (AppComponent)
            |           |     |           
            |           |     |-----[app.component.css]     (root component)
            |           |     |           - Defint the base CSS stylesheet for the root (AppComponent)
            |           |     |           
            |           |     |-----[app.component.spec.ts]
            |           |     |           - Define a unit test for the root (AppComponent)
            |           |     |           
            |           |     |-----[app.module.ts]
            |           |                 - Defines the root module, named (AppModule), that tells Angular how to assemble the application
            |           |                 - Initially declares only the (AppComponent)
            |           |                 - As we add more components to the app, they must be declared here
            |           |     
            |           |-----[Project Assets Files]  [assets/]
            |           |
            |           |           - Contains image and other asset files to be copies as-is when you build your application
            |           |           
            |           |-----[favicon.ico]
            |           |           - An icon to use for this application in the bookmark bar
            |           |           
            |           |-----[index.html]
            |           |           - The main HTML page that is served when someone visits your site
            |           |           - The CLI automatically adds all JavaScript and CSS files when building you app
            |           |                 - So we Typically don't need to add any <script> or <link> tags here manually
            |           |     
            |           |-----[main.ts]               (main entry point)
            |           |           - The main entry point for your application
            |           |           - Compiles the application with the JIT compiler and bootstraps the application's root module (AppModule) to run in the browser
            |           |           - We can also use the AOT compiler without changing any code by appending the --aot flag to the CLI build and serve commands
            |           |
            |           |-----[styles.css]
            |                       - Lists CSS files that supply styles for a project
            |      
            |-----[Library Project Files]       => ng generate library myLibrary
                  |     
                  |---- [Library Configuration Files]
                  |     |
                  |     |-----[ng-package.json]
                  |     |           - Configuration file used by ng-packagr for building your library
                  |     |     
                  |     |-----[package.json]
                  |     |           - Configures npm package dependencies that are required for this library 
                  |     |           
                  |     |-----[tsconfig.lib.json]
                  |     |           - Library-specific TypeScript configuration, including TypeScript and Angular template compiler options'
                  |     |     
                  |     |-----[tsconfig.lib.prod.json]
                  |     |           - Library-Specific TypeScript configuration that is used when building the library in (production mode)
                  |     |           
                  |     |-----[tsconfig.spec.json]
                  |                 - TypeScript configuration for the library tests
                  |     
                  |-----[Library Source Files]      [src/]
                        |    
                        |-----[lib]
                        |           - Contains Library project's logic and data. Like an application project, a library project can contain Components, Services, modules, directives, and pipes
                        |     
                        |-----[public-api.ts]
                                    - Specifies all files that are exported from your library


[JIT Compiler/ AOT Compiler] ------------------------------------------------------------------       
      
      // By default Angular are set up for (JIT Compilation) Just-In-Time   
      
      [JIT] // Compile TypeScript just in time for executing it in the client side browser... 
                  
            - Each file compiled separately
            - No need to build after changing your code and before reloading the browser page ( because in AOT you have to build the application after each modification before sent it to the client  )
            - Suitable for local development ( because compilation no a separate step )
            
            [Timing]
                  - Happens at runtime, in the browser before the application runs
            [Process]
                  - The Angular application's templates and TypeScript code are shipped to the client side as is. the compilation of application's template and typescript code in the user's browser during application startup 
            [Pros]
                  - Quick Development, you don't need to wait for separate compiltion step each tie you make a change, this speed boost help you build and test your website more effieciently 
                  - Easy Debuggin, JIT makes it simple to find and fix errors in your code it gives you real-time feedback on any issues, making it easier to identify and solve problems as you work
                  - Flexible Prototyping, JIT is perfect for trying out new ideas and experimenting with different desings it allows you to see immeiate result, so you can quickly iterate and improve your website
                  - Interactive Learning, For those learnig Angular, JIT is a great learning tool. It lets you play with the code and see theeffects in real-time, making the learning process more engaging and interactive 
                  - the browser loads a smaller payload initially, as the tmeplates and code are shipped as is 
                  
            [Cons]
                  - Slower application startup time as compilation occurs on the client side 
                  - Users might experience a delay before the application becomes fully interactive 

            [JIT Scenario]
                  - You write code using HTML, CSS, and TypeScript for your angular website
                  - When someone opens you website in their browser, the JIT compiler starts working 
                  - The JIT compiler reads and understands your code, looking for angular components and instructions\
                  - It then translates your code into optimized JavaScript, a language the browser understands
                  - The browser uses this translated JavaScript to build and display your website on the screen
                  - During development, if you make changes to your code, the JIT compiler quickly re-translates the modified code  allowing you to see the changes instantly
                  - Whe nusers interact with your website, the browser uses the translated JavaScript code to respond to their actions and provide a dynamic user experience
            
      
      [AOT] // Compile TypeScript during build phase (Ahead of Time) 
            - Compiled by the machine itself, via the command line (Faster)
            - All code compiled together, inlining HTML/CSS in the scripts
            - No need to deploy the compiler (Half of Angular size)
            - Suitable for production builds
            
            [Timing]
                  - AOT compoilation occurs before the application is deployed to the client typically during the build process
            [Process]
                  - The Angular appilication's templates and TypeScript code are compiled into JavaScript and HTML during the build phase. This compiled ccode is then shipped to the client-side, and there is no need for the client to perform compilation
            [Pros]
                  - Faster application startup time as there is no compilation on the client side
                  - Smaller Payload sent to the client, as only the compiled code is shipped
                  


[Component] ------------------------------------------------------------------

      - [Create Automatically] 
            - using command @ ng g c ComponentName --skip-tests         // the flag used to prevent creating specs.ts file for testing
            - --inline-template  --inline-style                         // uses compnent decorator property template and styles to write both in the same file without creating files form both html and css
            - --flat                                                    // Creates the comopnent in the same directory without creating a specific directory for them 
            Note : any flag applied on the creation of the project applied on all angular elements 
            
      -  [Create Manually] 
            - Create a typescript file
            - make a normal importable class (export) class and then we add the @Component class decorator 
            - Used metadata for the component decorator is :
                  - selector:                         // string  , defines how component can be used in other templates
                  
                  - template/templateUrl              // string  , defines the HTML template whether it was inline or external both take string [template/ url to an existing template]
                  
                  - styles/styleUrls                  // string[], defines the style sheets for the component whether it was inline of external, both take array of string
                  
                  - animations                        // any[]   , defines the animations for the component => Identifiers[triger, state, sylte, animate, transition]
                  
                  - changeDetection                   // changeDetectionStrategy{Default, OnPush}, specify the changes detection between component interactions(@input, @output), Default => detect changes automatically, OnPush => detect changes only on triggering it from the other comopnent to make it affected in the second component, higher performance in OnPush Option
                  
                  - viewProviders                     // Provider[], defines the providers especialy the services that you want to provide it for the component level, in case we didn't make that provider in the root level or the level that contain the current component like @Injectable({providedIn: 'root', // or specify a module where the service is provided})
                                                      // @Injectable(), here we create a provider which is injectable but not providedin any level, no one can use it, unless you added to the user (component) viewProviders
                  - encapsulatin                      // ViewEncapsolation{none, emulated, shadowDom}, defines the style policy
                  
                  - interpolation                     // [string,string], defines the way that how we could use the interpolation between the class file and the tmeplate, like the default is ['{{', '}}']
                  
                  - preserveWhiteSpaces               // boolean, defines how to treat white spaces in from the compiled template
                  
                  - standalone                        // boolean, don't need to be declared in NgModule, Manages their own template dependencies
                  
                  - imports                           // (Type<any>[]|ReaadonlyArray<any>)[], Defines the modules and other declaration to use it in this standalone component only available for standalone components, define standalone component's template dependencies, can import other standalone components, pipes, directives, and pipes as well as existing NgModules
                  
                  - schemas                           // SchemaMetadata[], Elements and properties that are neither Angular compoennts nor directives must be declared in a schema 
                  
[ Component Animations ] ------------------------------------------------------------------
      @component{

            selector: 'app-header',
            
            template: `<nav>              // [We're using back tic for multiple line]
                             <button type="button" (click)="toggle()">Toggle Open/Close</button>
                       </nav>

                       <div [@openClose]="isOpen ? 'open' : 'closed'" class="open-close-container">
                             <p>The box is now {{ isOpen ? 'Open' : 'Closed' }}!</p>
                       </div>`,                 

            animations: [
                  trigger('openClose', [

                        state('open', style({
                              height: '200px',
                              opacity: 1,
                              backgroundColor: 'yellow'
                              })
                        ),

                        state('closed', style({
                              height: '100px',
                              opacity: 0.8,
                              backgroundColor: 'blue'
                              })
                        ),

                        transition('open => closed', [
                              animate('1s')
                        ]),

                        transition('closed => open', [
                              animate('0.5s')
                        ]),

                  ]),
            ]
      }
 
[ Component Life Cycle Hooks ] ------------------------------------------------------------------

      - Are methods that you can implement in your components to interact with the life cycle of a component
      - these hooks allow you to perform actinos at specific moment during the creation, updating, and destruction of a component 
      
      - [OnChanges]     ngOnChanges => is called when on or more inpur of the properties have been changed
                        @ ngOnChanges(changes:SimpleChanges){console.log(changes['propertyName'].currentValue)}   // [currentValue, previousValue]
      
      
      - [OnInit]        ngOnInit    => is called once after the compnent have been initalized after the constructor       
                        @ ngOnInit(){//do something ...}                     
      
      
      - [OnDestroy]     ngOnDestroy => this hook is called just before the component is destroyed its a good place to clean resources and unsubscripe from observables
                        @ ngOnDestroy(){//do something ...}
 
[ Component View Encapsulation ] ----------------------------------------------------------------
 
      - [ViewEncapsulation.ShadowDom]           // Angular uses the browser's built-in Shadow DOM API to enclose the component's view inside a shadow Root
      
      - [ViewEncapsulation.Emulated]            // Angular modifies the component's CSS selectors so that they are only applied to the component's view and do not affect other 
      
      - [ViewEncapsulation.None]                // Angular does not apply any sort of view encapsulation meaning that any styles specified for the component are actually globally applied and can affect any HTML element preset within the application
      

[Component Interactions] ------------------------------------------------------------------ 

      [ Input Binding (@Input()) ]
            - From Parent To Child        
                  - 1 - in the child ts file we create a property with @Input decorator
                        @ @Input childProperty:string = '';
                        
                  - 2 - in the parent ts file we create a property
                        @ parentProperty:string = '';  
                        
                  - 3 - in the parent html file we follow this line Paradigm
                        @ <app-child [childProperty]="parentProperty" ></app-child>
                        
                  [@Input]
                        [alias]           // string, The name of the DOM property to which the input property is bound 
                        [required]        // boolean, Whether the input is required for the directive to function
                        [transform]       // function, Function with which to transform the input value before assignng it to the directive instance
                  

      [ Output Binding (@Output()) ]
            - From Child To Parent        
                  - In the Child ts file
                        - Create a Property 
                              @ ChildProperty : string = '';
                              
                        - Create an Event
                              @ @Output() CustomEvent = new EventEmitter<string>();
                              Note: <string> means that the event are going to handle string payloads
                              
                        - Create a Function that Emit the customEvent with ChildProperty
                              @ EmitEvent(){this.CustomEvent.emit(ChildProperty)}
                              Note: // --$-- If we won't to stop binding just reset the childProperty after the previous line
                              
                  - In the Parent html file 
                        - Assign the custom event to the event handler in the child component directive
                              @ <app-child (customEvent) = 'EventHandler($event)' ></app-child>
                              
                  - In the Parent ts file 
                        - Create a Property
                              @ ParentProperty :string = '';
                        
                        - Create a function 
                              @ EventHandler(e:any){ParentProperty = e;}
                  
                  - Create a button that Fire the EmitEvent() to start transferring the data from the child to the parent
                  
                  [@Output]
                        [alias]           // string, The name of the DOM property to which the input property is bound


[Binding Types] --------------------------------------------------------------
 
      - Interpolation Binding             (One-Way) 
            @ <p>{{ VariableInExportClass }}</p>
      
      - Property Binding                  (One-Way)
            @ <img [src]="VariableInExportClass">
            
      - Event Binding                     (One-Way)
            @ <button (click)="FucntionInExportClass()">Click me</button>
            
      - Forms / [(ngModel)] Binding       (Two-Way)   => considered as Attribute Directive 
            @ <input [(ngModel)] = 'VariableInExportClass'>             // to use it we must import [FormsModule] in the app.module.ts in the imports section
            @ <input [ngModel]="name" (ngModelChange)="name = $event">  // this is the unshorted version of the two way binding [(ngModel)]
      
      - Attribute Binding 
            @ <input [attri.maxLength] = "VariableInExportClass" >
            
      - Class Binding
            @ <div [class.container] = "conditionInExport"></div>       // will be container class if the conditino become true in the get in export section
            
      - Style Binding 
            @ <div [style.color] = "VariableInExportClass"></div>
            
            
[Pipes] --------------------------------------------------------------

      - Pipes are features that allows you to trnasform and format data in your template  
      - Used to modify the way the data is displayed in the view without changing the actual data itself
            @ {{ myDate   | date:'short' }}
            @ {{ myNumber | number:'1.2-2' }}
            @ {{ myString | uppercase }}
            @ {{ price    | currency:'USD':true }}
            
      - Also we can create custom pipelines using @Pipe decorator 
            - ng generate pipe myCustomPipe --skip-tests
            - or create ts file, import Pipe decorator and and PipeTransform (implement it in the class)
                  - create a transform method (Implomented from the interface) takes (value: unknown, ...args: unknown)
            - [@Pipe({name:'custom'})]
                  [name]            // the name of the custom pipe which will be used in the template 
            @ {{ myData | custom }}
      
[Template reference variables, ElementRef, and ViewCihld] -----------------------------

      [Template Reference Variabale]
            <input type="text" #paragraph>                        // Refering the input as #paragraph reference  Type is => [HTMLInputElement]
            <button (click)="method(paragraph)">start</button>    // Sending that reference to the method
            // We can print its value, setattribute, 
      
      [ElementRef and ViewChild]
            @ViewChild('refName')               // Take the reference name in the template
                  SelectedElement: ElementRef           // This property holds the selected html element using the view child decorator 
                        this.SelectedElement.nativeElement.value / style / click() / ...
            // After that we can control element's value, style, attribute, FireEvent of another html element and so on
      
                            
[Angular Directives] --------------------------------------------------------------
      // Are defined through modules such as CommonModule, RouterModule, FormsModule, ...
 
      - Component Directive 
            <app-root></app-root> 
      
      - [Attribute Directive]  
            
            - Shape: [ng-....]      =>      takes object "{'___':____ , ... }"
            
            - [ng-class]
                  @ <div [ng-class] = "{'container':IsValid, 'bg-primary':!IsPrimary}">Text</div>
            - [ng-style]
                  @ <div [ng-style] = "{'color':color}">Text</div>      // where color is a string value in the ts file 
                  
            - [(ngModel)]
                  - Adds two way data binding 
      
      - [Structural Directiive]
            - *ng-if
                  @ <div *ng-if="Show">of the property 'show' is true this element is true</div> 
            - *ng-for
                  @ <div *ng-for="let item of array">repeatedText {{item}}</div>
                  [ng-for and trackby]
                        - by default angular track the data by their references. So if I reassign list of data to the 
                              variable which ngfor use to list the elements, the reserve in different places in the memory 
                              so the angular look at them like their new to it because angular look to data's references despite 
                              of the data is the same but their locations in the memory have changed so Angular reinitialize the 
                              html elemnts again that used with ngfor. To fix it we have to make the angular track this data by 
                              something tracking something constant instead of looking to the object references that wouldn't 
                              change like the data's IDs. So if we reload the data angular will notice no changes because he is 
                              looking to the IDs of the objects in the list then he won't reinitialize the html elements. In this 
                              scenario with large data will offer big difference in performance
                              
                              [HTML Template]
                                    // Note: don't use '()', because, trackby expect a function reference not a function call
                                    - <ul><li *ngFor="let item of dataList; trackby: trackMethod">{{item.name}}</li></ul>    
                              
                              [Class File]
                                    // Now Anguar track with the item's id instead of tracking them by their locations in the memory which leads to bad performance due to reinitialization every time
                                    - trackMethod(index, item){return item ? item.id : undefined}
                  
            
            - [ngSwitch] [ngSwitchCase] [ngSwitchDefault]
                  @
                      <div [ngSwitch]="value">
                        <div *ngSwitchCase="'case1'">Content for case 1</div>
                        <div *ngSwitchCase="'case2'">Content for case 2</div>
                        <div *ngSwitchDefault>Default content</div>
                      </div>
      
      [ng-container]
            - A special element that can hold a structural directives without adding new unnecessary elements to the DOM
            
            [Example (without ng-container)]
                  <ul>
                    <li *ngFor="let item of items" *ngIf="item.isValid">{{ item.name }}</li>    // Here we will get an error because we can't have multiple structural directives applied to a single element
                  </ul>                                                                         // To fix it we have to add another element to make each element takes one structural directive to avoid error
                                                                                                // But we will have extra unnecessary element, so here we can use ng-container instead of using html element to avoid creating extra elements
            [Example (with ng-container)]
                  <ul>
                    <ng-container *ngFor="let item of items">                                   // This line will not create an extra element 
                      <li *ngIf="item.isValid">{{ item.name }}</li>
                    </ng-container>
                  </ul>


      [Custom Directive]  
            import { Directive, ElementRef, HostListener } from '@angular/core';
            @Directive({
              selector: '[my-class]',      // this is the name of the newely created directive 
              standalone: true,              
            })
            export class MyClassDirective {
              constructor(private elementRef: ElementRef) {
                  this.nativeElement.style.transitionDuration = '300ms'
              }

            @HostBinding('style.backgrounColor') backgroundColor !: string | null;        // instead of using 'this.el.nativeElement.backgroundColor' we user 'this.backgroundColor'   

            @HostListener('click') function(){
                  this.backgroundColor= 'red'
            }

              ngOnInit() {    // explained later
                this.elementRef.nativeElement.classList.add('my-class');      // this directive is used to add classes to the selected element
              }
            }     
            
            [user]
            @Component({
                  standalone: true,
                  imports: [directiveName]
            })

  
[ Driven-Template Form ] -------------------------------------------------------------- 

      // [#myform]            => Create a local template variable         
      // [ngForm]             => a reference to the angular NgForm directive, It represents the Angular form object and provides access to the form's methods and propertes like (valid, value, invalid, dirty, touched ...)
      // [#myForm="ngForm"]   => create a reference to tha angular form, which make the [#myForm] able to access the Angular Form properties and methods
      // [ngSumbit]           => an angular directive used to bind bind a function to submit form of an angular form 
      
      <form #myForm="ngForm" (ngSubmit)="Submit(myForm)">
          
          // [(ngModel)]      => We must use the NgModel Directive two way data binding to let it know that it's a template form control
          <input type="text" [(ngModel)]="formData.name" required>     

          // Binding it to the object 'formData' which have proerty 'pasword'
          <input type="password"  [(ngModel)]="formData.password" required>

          // [myForm.invalid] => As we said we can use the Angular form properties and methods because we created a reference to the angular form within the template 
          <button [disabled]="myForm.invalid">Submit</button>  
          
      </form>

[ Reactive Form ] -------------------------------------------------------------- 

      - Add Reactive Form Module to the app.module file (NgModule)
      
      [FormGroup]
      
            - Defines a form with a fixed set of controls that you can manage together 
                  - the FormGroup is an [Object] and the FormControls inside it are [Properties]
            - [Template]
                  <form [formGroup]="myForm" (submit)="submit()">             // binding the formgroup name and add the submit handler to the submit event
                      <input type="text" formControlName="name">              // binding the control name that defined in the class file 
                      <input type="text" formControlName="password"           
                      <button type="submit">Submit</button>                   // Normal button to fire the submit button on click
                  </form>
                  
            - [Class File]
                  myForm:  FormGroup = new FormGroup({                         // Initialize and assign form group
                    name: new FormControl('', [Validators.required]),          // Define form contorl with specific validators
                    password: new FormControl('', [Validators.required])       
                  })    
                  submit(){                                                    // Define Submit handler method
                    console.log(this.myForm)    
                  }     
                        
                  - also we could use formbuilder to make it more easy  
                        constructor(private fb: FormBuilder){}                 // Inject the FormBuilder
                        myForm1: FormGroup = this.fb.group({                   // Initialize formgroup and create form controls using form builder 
                          name: ['', [Validators.required]],
                          password: ['', [Validators.required]]
                        })
                        
      [FormArray]
      
            - Defines a dynamic form where you can add and remove controls at run time 
                  - the FormArray is an [Array] and the FormControls inside it are [Elements]
                  - We could add more controls in the run time 
            
            [Class File]
                  public mainForm: FormGroup = this.fb.group({
                    emailAddress: [null, [Validators.required]],        // FormGroup Control [An Object Property]
                    phones: this.fb.array([                             
                      this.fb.control(null, [Validators.required])      // FormArray Control [An Array Element]      
                    ])
                  })
                  
                  get Phones(): FormArray {
                    return this.mainForm.get('phones') as FormArray;    // To be able to use the phones controls in the template (avoid possibly null object)
                  }
                  
                  public addPhone() {
                    (<FormArray>this.mainForm.get('phones')).push(this.fb.control(null, [Validators.required]));      // We have to explicitly get the value as FormArray (Assertion / Type Casting) using '<>' assertion operator
                  }
                  
            [Template File]
                  <form [formGroup]="mainForm">
                      <input type="email" formControlName="emailAddress">
                      
                      <div formArrayName="phones">                                        // FormArray Container, holds all the controls of the FormArray      
                          <ng-container *ngFor="let item of Phones.controls; index as i"> // using 'Phones' getter and loop over the controls
                              <br>
                              <label>email {{i}}</label>
                              <input type="text" formControlName="{{i}}">                 // the index of the conrol in formarray
                          </ng-container>
                          <br>
                          <button (click)="addPhone()">Add More Phones</button>           // Used to add more phone control in FormArray
                      </div>
                  </form>
                           
                           
------------------------------- [ Routing ] -------------------------------

     // lazy routing => create standalone components => create routes ts file => use it in routing module , use loadchildren: () => import('path').then(r=> r.products)      r here is the file, and products is the arrya inside the file that contains the paths
      loadcomponent works only with standalone component 
      // different between loadchildren and loadcomponent
      // Reactive X

      - in app-routing.module.ts file we add the pathes and tha component
            @ const routes:routes = [{path:'url', component:ComponentName}]
            @ const routes:routes = [{path:'**', component:NotFoundComponent}] // ** means wild card (match any url that doesn't match any of the defined routes also used as [Catch-All])
            @ const routes:routes = [{path:'url', redirecto:''}]  
            @ const routes:routes = [{path:'url/:id', component:ComponentName}]
      
      
      
      - we can add route parameteres
            @ const routes:routes = [{path:'url/:id', component:ComponentName}]     => where the id is a parameter 
            
      - in the main html file we add 
            @ <router-outlet></router-outlet> here will be placed the loaded comopnent from the router 
            
      - in the html element we add 
            @ [routerLink] = "['path', 'path']" to load that component 
            
      - Note that it works by order => we have to put the last expectations in the end of the array 
            @ {path:"**", compenent:NotFoundComponent }     => we have to put it in the end of the route array 
      

------------------- [ Dependency & Dependency Injection ] ------------------

      - we in angular framework we define the dependencies that a component or service needs in the constructor
            constructor(data:dataService, router:Router, activatedRoute: ActivatedRouter){}     // dependencies injection
      - then the framework automatically inject the required dependencies 
      - we list the dependencies as a parameter in the constructor 
      - so we define the dependency in the constructor 
      - in the OnInit() we assign the data that came from these dependencies       
      
    
------------------------------- [ Services ] -------------------------------

      - to create service
            @ ng g s --skip-tests
            
      - make the service get the data from the model that you want to share it 
            - We imoprt that class and use the sevice constructor to get the data in a variable that we created in the service 
                  @ let data:IStudent[]=[]; constructor(){ this.data = ImportedData }
      
      - after that we have the data and we create the required functions to be able to do crud operations like create / delete / remove 
      
      - in the component we inject this service in the constructor and assign the data in the ngOnInit function
            @ constructor(private data: ServiceName , other services ... ){} ngOnInit(){ this.MyVariable = this.data}
            
      - to modify the data we have to make functions in the service ts file to add, delete
      
------------------------------- [ Built-In Services ] -------------------------------
     
      [ ActivatedRoute ]
            - Provides infromation about the route's parameter, data, and other related parameters
                  @ constructor (private route:ActivatedRoute){} ngOnInit():void{ this.data = this.route}
                  
            - We use it to access the route parameters and query parameters like .../Products/23 => where 23 is a parameter we can obtain it using this service 
                  @ data.snapshot.params => object of the params in the url
            
      [ Router ]
            - define it in the prameter of the class and then assign it to your data in the ngOnInit function            
            - navigate to another path
                  @ router.navigate(['/home'])
                  @ [routerLinkActive] = "'active'" // we could add more than one class, will be applied if we are on the link that deteremined in the routerLink
                  @ [routerLinkActiveOptions] = "{exact:true}"
                  
      // TO BE CONTINUED ...  
                  
                  

------------------------------- [ Angular Material ] -------------------------------
      
      - It's a UI Component library, it provides wide range of components such as buttons, inputs, menus, and navigation bars also contain wide range of themes and customizable themes
            
      - install Angular Material 
            @ ng add @angular/material
            
            
                  
                  
                  
------------------------------- [ Reactive Forms ] -------------------------------
      
      we have [FormControl] and [FormGroup] and [FormBuilder] from '@angular/forms'
      
      - in the app.module.ts we have to import ReactiveFormsModule in imports section 
      - first we dclare a property from type FormGroup (must import)
      - in onInit method we initialize the previouse property and then declare new form control for each part of the form
      - [formGroup] => we assign it to the property from type form group in ts file 
      - formControlName => we assign it to the property from type formcontrol in ts file 
      
    
------------------------------- [ Api Service ] -------------------------------      
      
      ------------------------- [ in Service File ]
      
      - we Impoort [HttpClientModule] in app.module.ts file to be able to use the HttpClient service 
      - create new service for connecting to an api 
      - each category must have its api service and we must create Interface for each category that used in each api to recieve the data 
      - we create a variable that holds the url for the api data that we will connect to in this service 
            @ baseUrl = "http://localhost:3000/products"
            
      - in the service we inject the HttpClient sevice in the servce constructor
            @ constructor(private httpClient : HttpClient){}
            
      - after that we create the verbs funciton [ Get / Post / Delete / Put ]
      
      
      
      -------------------------[ in the component ts file ]
      - we inject the api servcie that connect to the products
            @ constructor (private products : ProductsServcie ){}
      


------------------------------ [ Json Web Token (JWT) ] ------------------------
      Construction
            - Header -- Payload -- Signature
            
      [Header]
            - Typically consists of Two parts [ The Type of The Token /&/ The Signing Algorithms ]
                  @
                        {
                              "alg":"HS265",
                              "typ":"JWT"
                        }
      
      [Payload]
            - Contains the claims which are statements about an entity 
            - There are three types of claims [ Registered / Public / Private ]
            - the informataion which it include is like the [ Subject / Not Valid Before / Expiration Date / Issuer ]
                  @
                        {
                              "sub": "12541231",
                              "name": "John Doe",
                              "Iat": 1516239022                   // Issued At Time
                              "exp": 1516241022                   // expiration
                              // we can add more claims about the user 
                        }
      [Signature]
            - is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way
            - the signature is created by taking the [encoded header / encoded payload / a secret if using HMAC / algorithm specified in the header and signing it ]
            - the header and the payload are encoded not encrypted so the user can decode it 
                  - but the signature is hashed with the result of ()
            how to include the jwt on client request header 
            how do we compare the time iat exp in the payload 
            
      

---------------------------------- [ Day Six ] ----------------------------------

[ Reactive Forms ]

 controlname.touched
 
 class invalid-feedback 
 
 npm i json-server

in the package.json file we determine the start script 
      json-server -- watch -p 3005 data.json                open data.json file in port 3005
            
            // we determine the port and 
            // json file must be string use replace to edit them all 
            
      
      add file data.json
      
      for connect to an api 
            - we create a service API Service 
            - import module =>      HttpClientModule => obtain the code that responsible for openning the connection to get post put delete verbs 
                  -- add that module to the httpclient 
            - in API Service 
                  - we have to determine the base URL
                  - we create service for each controller => posts / comments / categories / ...
                  - in each service we dtermine the base URL that the service will connect to 
                  - We inject the service 
                        @ constructor(private http: HttpClient){}
                  - Observables => is like Promise in js and we use it here 
                        - object contain three functinos [ next / error / complete ]
                        - we subscripe() on the observables to run the inner codes (call back )
                        
                        @ Subscripe({
                              next (data)=> {};
                              error (error) => {},
                              complete () =>{}
                        })
            would keep running in the background untill it got the complete and the API won't sent it 
                  - so we have to unsubscripe on the destroying 
                        @ ngOnDestroy(){unsubscript()}
                        
      HttpClient returns observable 
      
      in the api service 
            - getall():Observable<Iproduct[]> function => make it return this.http.get(this.baseURL)
                  we make the get generic because I know what will it return so we write in that way
                        @ return this.http.get<Iproduct[]>(this.baseURL)
                        
            - getbyid(i:number){return this.http.get($`{this.baseURL}/{id}`) }
      
      in the add 
      @ add(prod:Iproduct){return this.http.post(this.baseURL, prod);}
      
      in the edit 
      @ edit(id:number, prod:IProduct){reutrn this.http.put($`{this.baseURL} /{id}`)}
      
      in the delete
      @ delete(id:number){reutrn this.http.delete($`{this.baseURL}/{id}`)}
      
      
      for your knowledge we use httpclient service to be able to use the verbs
            - also you must know it return an observables
            - we must subscript to be able to use the data 
            
            this.api.getAll().succript({
                  next:(data) => {this.products = data},
                  error : (err)=> {console.log('Error'+err)},
                  complete: () => {}
            })
            
            
            
      what is guards in angular 
            @ ng g g guardName --skip-tests
            
            can deactivate 
            can activate 
            
            in the routes we add another property in the object properties after component, canActivate:[GuardName]
            we use to disallow users from accessing somewebsites unless it login 
            
            we are updating the list of the deleted item from the list using 
                  @ this.students = this.students.filter(item=> item.id != i) // filtering the list for the students that not i id
                  
                  
            edit using put verb takes two parameters (baseurl/id, object) where the object is the one to update
            
            
            github landing page like the instructor
                  
            reactive forms 
            connect to api
                  
                 
            @Input and @Output 
            Shared Services
            @ViewChild & @ViewChildren
            Component LifeCycle Hooks
            Router navigation and router parameter
            parent Child component hierarchy
            content projection => ng-content
            Event Emitters
            Rxjs

[Create Interceptor]
      - open terminal => app path
            - @ ng generate interceptor auth
      
      - in the interceptor file we will find these imports => [HttpInterceptor,HttpRequest,HttpHandler,HttpEvent]
      
      @ -------------------------------------------------------------
      - this method is autmatically call on each request and it have the request and the next,
      - request holds the request from the application and we have to assign it to the next
      - next is the property which hold the data for the server
      - so the interceptor the the request medium between the application and the server
        
        intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {

      - first we get the jwt token from the storage
          const token = localStorage.getItem('token');

      - second we check for the token is found
          if (token)
          {
            // in case the token found we create a clone from the request and add the token to the header
              // espicially to the bearer in which exists in the authorization in the header
            const clonedRequest = request.clone({setHeaders: {Authorization : `Bearer ${token}`}})

      - after cloning the request and add the token to the bearer in the authrorization in the header
      - we send the request
            return next.handle(clonedRequest);
          }
          else
          {
      - in case the token were not found we send the normal request without adding anything
            return next.handle(request);
          }
        }
      @ -------------------------------------------------------------
      

[Deployment]      

      -- [Build]
            - ng build              // (JIT) Just in Time compilation (by default)
            - ng build --aot        // (AOT) Ahead of Time compilation
            - Project will be published in [dist/] Directory 
            
      -- [Production (Budget)]
      
            - [initial]                   // This budget applies to the initial bundle size of your application
                  - [maximumWarning]      // Specifies the warning threshold, it the initial bundle size exceeds the specified size 
                  - [maximumError]        // Specifies the error threshold, if the initial bundle size exceeds 1 megabyte,
            
            - [anyComponentStyle]         // This budget applies to the size of styles (CSS) associated with any component in your application
                  - [maximumWaring]       // Specifies the Warning threshold if the styles exceed the specified size
                  - [maximumError]        // Specifies the error threshold if the Styles exceed the specified size
                  
      -- [Error 404 Not Found Page Solution(IIS Server)]

            - Install IIS URL Rewrite Module
            - add this snippet of code to the web.config file 
            -------------------------------------------------------------------------------------------
                  <?xml version="1.0" encoding="utf-8"?>
                  <configuration>
                    <system.webServer>
                      <rewrite>
                        <rules>
                          <rule name="AngularJS Routes" stopProcessing="true">
                            <match url=".*" />
                            <conditions logicalGrouping="MatchAll">
                              <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" />
                              <add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" />   
                            </conditions>
                            <action type="Rewrite" url="/" />
                          </rule>
                        </rules>
                      </rewrite>
                    </system.webServer>
                  </configuration>
            -------------------------------------------------------------------------------------------