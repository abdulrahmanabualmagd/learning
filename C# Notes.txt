--------------------------------------------------[Create Console Project] --------------------------------------------------
	- Bash => dotnet new console 	// [console, mvc, webapi, ...] [-o output, -n name, ...]
	- bash => dotnet run			// to run the project
	- bash => dotnet build          // build the application
	- bash => dotnet restore 		// install the necessary  
	
[Comments]
	- //							// Single Line Comment	
	- /* */                         // Multiple Line Comment
	- ///							// XML Comment 
	
-------------------------------------------------- [Data Tpyes] --------------------------------------------------
	
	- [ Integral Types ]
		- byte / sbyte		=> 8bit			
		- short / ushort	=> 16bit	=> System.Int16		//.Net Type
		- int / uint		=> 32bit    => System.Int32     //.NET Type
		- long / ulong		=> 64bit	=> System.Int64		//.NET Type
		
	- [ Floating-Point ]
		- float 			=> 32bit		0.1f			=> System.Single			
		- double 			=> 64bit		0.1				=> System.Double
		- decimal 			=> 128bit		0.1m			=> System.Decimal
		
	- [ Character ]
		- Char 				=> 16bit	=> System.Char
		
	- [ String ]
		- String 			=> 16bit/char	=> System.String
	
	- [ Boolean ]
		- bool				=> 1bit	=> true/false			=> System.Boolean
				
	- [ Date ]		
		- DateTime			=> 8bit							=> System.DateTime
		- DateTime date = DateTime.now;
		
	- [ Object ]
		- var person = new { name = "John", age = 25 };		// Anonymous types
		- Person person = new Person("john", 25);			// Instance from a Class Person
		- dynamic obj = new System.Dynamic.ExpanoObject();	obj.name = "John"; Console.WriteLine(obj.name);	// Dynamic Object
	
	- [ Nullable ]
		- [primitive] + [?]	=> allow null

	- [ Enumerations ]
		- enum 				=> value type that defines a set of named integral constants
		- enum Days {sat, sun, mon = 5, tues, }		// int x = (int)Days.sun;
		
	- [ Arrays ]
		- int[] data = {2,3,5} | new int[] {2,3,5} | new int[3] {2,3,5}
		
	- [ Structs ]
		- public struct Person { 
			public string name;
			public int age;   									                       
			public Person(){this.name = "John"; this.age = 25;}					// Constructor
			public void DisplayInfo(){ Conole.Writeline($"{name} {age}") }		// Methods
		}
	
	- [ Classes ] 	--------------------------------------------------
		- Members:		Fields, Methods, Properties(get, set), Constructor
		- Constructor: 	[ Default, Parameterized, DeepCopy, ShallowCopy, Static]
		- [ Parent Class(base) | Child Class(derived) | Abstract Class | Sealed Class | Static Class | Partial Class | Generic Class | Container Class ]
		- [ Singleton Class | Factory Class | Immutable Class | DTO Class | Attribute Class | Disposal Class |   ]
		
	- [ Interfaces ] 	--------------------------------------------------
		- public interface IMovable{ void Draw(); int X {get; set;} }
	
	- [ Other Types ]
		- dynamic 			=> Represents an object whose operations are resolved at runtime
		- var				=> Implicitly-typed variable, the type is inferred by the compiler
		
-------------------------------------------------- [ Operators ] --------------------------------------------------

	- Arithmetic Operators: 		=> [+, -, /, *, %]  
	
	- Comparison Operators: 		=> [==, !=, <, >, <=, >=]   
	
	- Logical Operators: 			=> [&&, ||, !]              
	
	- Assignment Operators: 		=> [=, +=, -=, *=, /=, %=]  
	
	- Inc and Dec Operators: 		=> [++, --]  
	
	- Bitwise Operators: 		=> [&, |, ^, ~, <<, >>]
		
-------------------------------------------------- [ Implicit / Explicit Conversions ] --------------------------------------------------
	- Implicit Conversion is done by the compiler if there is no data will be lost like:
		int x = 5;	double y = x;			// here x implicitly converted into double => no data loss
		
	- Explicit Conversion is done manually and need a cast to force it like:
		double x = 3.3; 	int y = (int)x;		// We have to cast the value as an int
		
-------------------------------------------------- [Built-In Methods] --------------------------------------------------

	- [String Class Methods]
		- .Length | [indexing] | .Substring() | .Concat | .Equals | .Compare | .ToLower
		  .ToUpper | .Trim | .Contains | .IndexOf | .LastIndexOf | .Replace | .Split
	
	- [Math Class Methods]
		- Math.[Add, Subtact, Multiply, Divide, Pow, Sin, Cos, Tan, PI, Log, Log10, Sqrt, Round, Ceiling, Floor, Abs]
	
	- [Array Methods]
		- .Length | [Indexing] | .CopyTo | .Clone | .Sort | .BinarySearch | .Fill | .Reverse | .Clear | .Equals | .ToList() | .Copy
		- int[,] matrix;
		- int[][] jaggedArray;
	
	- [Type Conversion Methods]
		- implicit / explicit (casting)
		- Convert.ToInt[16/32/64] | .ToString | int.Parse | int.TryParse 
		- [Boxing & UnBoxing]
			- [Boxing] 
				- ValueType 			=> 	ReferenceType
				- int intvalue = 42;		object BoxedValue = intvalue;
				
			- [Unboxing]
				- ReferenceType			=> 	ValueType
				- object BoxedValue = 42;   int intValue = (int)BoxedValue;
			
			- [Performance Considerations]
				- (memory allocation) new object is created in the heap and the reference to that object stored in the stack
				- (Copying) Copy the value type from the stack, which introduces overhead especially for larger value types
				- (Type-Checking Overhead) when unboxing a value from an object there's a need for type-checking to ensure that the object actually contains a value of the expected type
				
		- [explicit operator]
			- public static explicit operator double(myObject value){ return value.weight; }
			// User-defined explicit conversion operator which convert an instance from a class to a double
			
	- [Linq Methods]
		- Where | Select | OrderBy | OrderByDescending | GroupBy | Join | GroupJoin | Take | Skip
		- First | FirstOrDefault | Single | SingleOrDefault | Last | LastOrDefault | Any | All | Aggregate
		- Count | Sum | Min | Max | Average | Concat | Distinct | Union | Intersect | Except | AsQueryable
		- Reverse | AsEnumerable | ToArray | ToList | ToDictionary | OfType | Cast | ToLookup | Skip | Take 
	
	- [IO Methods] (using System.IO;)
		
		- [File Class]
			- File.ReadAllText("") 			=> Returns string
			- FileInfo("")					=> Returns FileInfo 
			- File.[Exists | Copy | Delete | Move | ReadAllLines | ReadAllBytes | WriteAllText | AppendTet | OpenRead | OpenWrite]
		
		- [Directory Class]
			- Directory.GetFiles("") 		=> Returns string[]
			- DirectoryInfo("")				=> Returns DirectoryInfo
			- Directory.[Exists | CreateDirectory | GetFiles | GetDirectories | GetParent | Move | Delete | GetLogicaldrives | GetCreationTime | GetLastAccessTime | GetLastWriteTime]
		
		- [Path Class]
			- Path.[Combine() | GetExtension | GetFileName | GetDirectoryName | GetFullPath | GetPathRoot | GetRandomFileName | IsPathRooted | ChangeExtension | GetTempFileName | GetTempPath ]
			
		- [FileStream Class]
			- FileStream fs = new FileStream("",FileMode.Open)	
			- fs.[Read | Write | Seek | Length | Flush | Close | Dispose | CanRead | CanWrite | CanSeek | Position ]
		
	- [Miscellaneous]
		
		- [Random Class]
			- Random random = new Random()
			- random.[ Next | NextDouble | NextByte(new byte[10]) | Convert.ToBase64String(new byte[10]) => string ]
			
		- [Convert Class]
			- Convert.[ ToBoolean | ToByte | ToInt32 | ToSingle | ToDouble | ToString | ToDateTime | ToChar | ChangeType ]
		
		- [DateTime & TimeSpan Classes]
			- DateTime.[Now | Today | UtcNow | Parse | TryParse | TopString("yyyy-MM-dd HH:mm:ss") | AddDays | Now.Subtract | Compare | Now.DayOfWeek | IsLeapYear ]
			- TimeSpan.[FromSeconds | FromMInutes | FromHours | Parse(time) | Compare |  ]
			- time.[Add | Subtract | TotalSeconds | TotalHours | TotalMinutes | ToString() | Equals(time2) | Zero ]

		- [Console Class]
			- Console.[Write | WriteLine | Read | Readline | ReadKey | Beep | Title | WindowWidth | WindowHeight | BufferWidth | BufferHeight ]
		
		- [Environment Class]
			- Environment.[GetCommandLineArgs | CurrentDirectoruy | Exit | GetFolderPath | MachineName | OSVersion | StackTrace | SystemDirectory | TickCount | TickCount64 | UserDomainName | userName | Version | WorkingSet]
		
--------------------------------------------------  [WorkFlow] --------------------------------------------------
	- [Sequential Execution]
		- Statements are executed one after the other in the order they appear in the code 
		
	- [Selection Statements]
		- if - else
		- switch
	
	- [Repetition Statements]
		- for		=> Number of Iteration is knew
		- wihle		=> Unknown number of iteration and continues looping until the condition change
		- do-while	=> Same as while but to ensure that the body executed at least once
		- foreach-in	=> Looping over Collections like Arrays, Lists, etc...
	
	- [Jump Statements]
		- break
		- continue
		- return
		- goto
		
	- [Exception Handling]
		- try-catch-finally
		- try{}catch(){}catch(){}finally{}
		- Use cases for finally [Cleanup Operations | Guaranteed Execution | Resource Deallocation]


	- [Functions & Methods]
		- Function is a self-contained unit of code that performs a specific task
			[AccessModifier] [ReturnType] [FunctionName]([Params]){[body]}
		- Method is a function but associated with an object or a class (a member of a class)
		- Arrow function like: public ind Add(int a, int b) => a + b;
		
-------------------------------------------------- [ Collections ] --------------------------------------------------

	- There are three types of collections pfovided by the .NET Framework
		- Collection (non-generic)
			- These are the older collection classes that existed before the introduction of generics in C# 2.0.
			- Less type-safe and less efficient than their generic counterparts
			- Like Queue, Stack, HashTable, ArrayList
			
		- Generic Collection
			- Introduced with C# 2.0, type-safe, more efficient, better performance due to elemination of boxing/unboxing, preferred to use in modern C# development
			- like List<T>, Dictionary<T>, Tvalue<T>, Queue<T>, Stack<T>
		
		- Concurent Collection
			- Itroduced in C# 4.0, designed for thread safety
			- Suitable for concurent operation in multithreaded scenarios
			- like ConcurrentQueue<T>, ConcurrentStack<T>, ConcurrentBag<T>, ConcurrentDictionary<TKey, TValue>
		
	
	Dictionary<TKey, TValue>: 	=> A collection of unique key-value pairs with fast access based on keys.
	List<T>: 			=> A dynamic array implementation for creating resizable lists.
	Queue<T>: 		=> Represents a first-in, first-out (FIFO) collection of objects.
	SortedList<TKey, TValue>: 	=> A collection of key-value pairs automatically sorted by keys.
	Stack<T>: 		=> Represents a last-in, first-out (LIFO) collection of objects.
	HashSet<T>: 		=> An unordered collection of unique elements with high-performance set operations.
	LinkedList<T>:		=> Represents a doubly-linked list for efficient insertion and removal.
		
	

 -------------------------------------------------- [ Access Modifier ] --------------------------------------------------
 
	- [ public ]			=>  	Visible over the entire solution.
	- [ private ]			=>   	Limited to the class scope.
	- [ internal ]			=>  	Visible only inside the project (namespace or assembly).
	- [ protected ]			=>  	Limited to children (derived classes) within the solution.
	- [ proteced internal ]		=>  	project scope + children scope in solution
	- [ private protected ]		=>  	Limited to children within the same assembly.

 -------------------------------------------------- [ Classes ] --------------------------------------------------

	- Blueprint or a template for creating objects
	
	- Members [ Fields(Attributes/Variables) | Properties | Methods | Constructors ]
	
	- Constructors [ Default, Parameterized, DeepCopy, ShallowCopy, Static ]
	
	- Property Accessor: [ get | set ]
	
	- [ Class Inheritance ]
		- Class can inherit only from a anothe single class and multiple Interfaces
		- class Dog : Animal, IMovable, ITouchable
		
	- [ Class Types ]
		
		- Abstract Class		=> cannot be instantiated. Could only inherit from it, become (parent) only
		- Sealed Class		=> can be instantiated but can't be inherited, become (child) only 	
		- Static Class		=> can't be instantiated also Contain only static members like Math class(Implicitly Sealed) 
		- Partial Class               => is defined in multiple files 
		- Generic Class		=> can with any datatype
		- Container Class		=> holds and manages a collection of other objects, encapsulating their functionality
		- Singleton Class		=> ensures only one instance is created and provides a global point of access to it
		- Factory Class		=> responsible for creating and returning instances of other classes
		- Immutable Class		=> whose instances can't be modified, enhancing predictibility and thread safety
		- DTO Class		=> used for transferring data between software application subsystems and distributed systems
		- Attribute Class		=> defines custom metadata and can be attached to code elements 
		- Disposal Class		=> implementing the IDisposable interface used for releasing unmanaged resources such as file handles or database connections
		- Concrete Class		=> Can create objects, have a complemete Implementation for all methods declared(non abstract method[ready to create objects])	
		
		---------------------------------------------------
		| Class Type        | Parent 	| Child 	| Object| |
		---------------------------------------------------
		| Static Class    	| No    	| No      | No      |
		| Abstract Class  	| Yes   	| Yes     | No      |
		
		| Sealed Class    	| No    	| Yes     | Yes     |
		| Attribute Class	| Yes   	| Yes     | No      |
		| Singleton Class 	| Yes   	| No      | Yes     |
		---------------------------------------------------
		
-------------------------------------------------- [ Classes Relations ] --------------------------------------------------

	- [Inheritance]
		- class inherit properties and members from another class and become derived(child) from the base(parent)
	- [Composition]
		- Involve Creating an instance of one class within another, The outer class depend on the inner class
	- [Agregation]
		- a special form of association where one Class contain another class inside it but not depend on it 
	- [Association]
		- bi-directional relationship, one-to-one, one-to-many, many-to-many
	- [Dependency]
		- a weaker form of accociation, occurs when a class relies on another class TEMPORARILY
	
-------------------------------------------------- [ Interfaces ] --------------------------------------------------
	
	- public interface IDrawable{ void method();  int id{get;set;} }
	- Contains Properties and Methods without body;
	- avoid overloading, to avoid ambiguity and implement SOLID ISP(interface segregation Principle)
	- use default value instead of overloads => void Method(int id, string name = "N/A") here name is optional because it have a default value
	- if there are multiple logical variations of a method, consider creating separate interface for each variation
	
	- [Methods] 	=> Implement Methods without providing an implementation(no body)
	- [Properties]	=> Declare a contract for a getter, setter, or both
	- [Events]	=> Declare a contract for subscribing and unsubscribing to an event
	- [Indexers]	=> Declare Indexers
	- [Nested Types]	=> Can Contain other types including nested interfaces or classes
	- [Default Interface Member (C#8.0 or later)]	=> Provide a way to include method implementations in interfaces, Classes can choose to use the default implementation or provide their own 
	- [Static Members (C#8.0 or later)]		=> Can include static members, these members are associated with the interface itsefl and not with any specific instance, only belongs to the interface
	

-------------------------------------------------- [ Built-In Interfaces ] --------------------------------------------------

	- [IEnumberable]		=> Represents a collection that can be enumerated (iterated) using 'foreach' loop
	- [IEnumerator]		=> Provides a way to iterate through a collection
		- Used to make the collections Enumerable by Implementing the interfaces IEnumerable and IEnumerator
		- IEnumerable Provide a way to iterate over any list  
	
	
	- [IComparable] 		=> Defines a method to compare an object with another of the same type
		- Choose the way you want to compare between two objects like compare objects by their Ids or names
		- Within the same class unlike IComparer 
	- [IComparer]		=> Defines a method to compare two objects of the specified type 
		- Used to choose the way to compare between class instances but in seperated class
		- The difference between IComparable  & IComparer is that IComparer provide a seperate class for comparison
	
	- [IEnumerable<T>]  	=> Represents a strongly typed collection that can be enumerated.
		- In Deferred execution, it filter the data in the client side after retreiving the data
		
	- [IEnumerator<T>]  	=> Provides a way to iterate through a strongly typed collection.
	
	- [IQueryable]  		=> Provides functionality to evaluate queries against a specific data source.
		- In Deferred execution it filter the data in the server side before getting the data
		- Is an interface defined in System.Linq, it's part of the language integrated query (LINQ)
		- Extends IEnumerable
			- able to build and execute more complex queries that can be translated into a form that is understood by the underlying data source
			- Allow deffered execution, with IEnumerable the entire dataset is loaded into memory before any filtering or projection is applied
			- On the other hand IQueryable allos the query to be composed and transformed into a format that is optimized for specific data source
			- The query is not executed until the data is actually needed which can result in more efficient and optimized queries
	
	- [IDisposable]  		=> Defines a method to release unmanaged resources.
	- [IFormattable]  		=> Defines a method to format the value of an object into a string representation.
	
	- [IEquatable<T>] 		=> Provides a method for comparing the equality of objects of the same type.
	- [IConvertible]  		=> Defines methods for converting an object to another type.
	- [ICloneable]  		=> Defines a method to create a shallow copy of an object.
	- [INotifyPropertyChanged]  	=> Defines an event for notifying clients when a property value changes.
	- [IAsyncResult]  		=> Represents the status of an asynchronous operation.
	- [IList<T>]  		=> Represents a list of objects that can be individually accessed by index.
	- [ICollection<T>]  	=> Defines methods for manipulating generic collections.
	- [IDictionary<TKey, TValue>] => Represents a generic collection of key/value pairs.
	- [IComparable<T>]  	=> Defines a method to compare an object with another object of the same type.
	- [IEqualityComparer<T>] 	=> Defines methods for comparing equality of objects of a specific type.
	- [IEquatable<T>]  		=> Provides a method for comparing the equality of objects of the same type.
	
-------------------------------------------------- [ Indexer ] --------------------------------------------------
	
	- An indexer in C# allows access to elements within this class using array-like syntax. 
	- For instance, if we have a class 'Person' and another class 'PList' containing an array of persons ('_plist'), 
	- we can access this array using the indexer. 
	- The indexer is similar to a property, but it permits indexing the class by adding square brackets '[]' to the instance name.
	       
-------------------------------------------------- [Generics] --------------------------------------------------
	- Writing a code that can work with any data type.
	- We can use Generic method in non-generic class
	- [Generic Class & Method]
		//Generic Class
		public Class GenericClass<T>
		{
			private T genericField;
			public GenericClass(T vlaue){
				GenericField = value;
			}
			//Generic Method
			public T GetValue(){
				return genericField;
			}
		}
		Genericclass<int> data = new GenericClass<int>(3);
		
	- [Generic Interfaces and Delegates]
		- public interface IGenericInterface<T>{ T GetValue(); }
		- public delegate void GenericDelegate<T>(T argument) 
		
	- [Constriants]
		- Used with Generic types to specify the capabilities or characteristics that the type parameter must have 
			- where T : class				// Ensures that the type argument is a reference type (class)
			- where T : struct				// Ensures that the type argument is a value type (struct)
			- where T : new()				// Ensures that the type argument has a parameterless constructor
			- where T : myBaseClass			// Ensures that the type argument must be or derive from a specific base class 
			- where T : IMyInterface		// Ensures that the type argument implements a specific interface
			- where T : U					// Ensures that the type argument must be or derive from the type specified by U
			- where T : notnull        		// Ensures that the type argument is non-nullable reference or non-nullable value
		- Use benefits => [ Type Safety | Reusability | Avoid Reflection | Prevent Nullability | Readability and Intent ]
		- public class Employee(): Person, IWorkable, 
	
-------------------------------------------------- [Delegate] --------------------------------------------------
	- A type which represents references to methods with a particular parameter list and return type
      - Pass a function as a parameter to another function
      - Create new delegate 
            - public delegate void MyDelegate(string message)           // A Reference Type which match only the methods that returns void and take string as a parameter 
                                                                                                           // MyDelegate is a type not an instance
      - Create Instance from the delegate
            - MyDelegate print = (a) => Console.WriteLine(a);             // Create an Instance(print) from MyDelegate Delegate and                                   
	
      
	- public delegate void MyDelegate(string message);	            // Delegate Creation, Assignable with methods void return type and takes string as a parameter 
	- public class MyClass{                                                                   
		public void MyMethod(string message){				      // We will assign the reference of that method to a variable of MyDelegate Type
			Console.WriteLine(message);
		}
	}
	- MyClass obj = new MyClass();								// Create Instance from the class MyClass to use Its method
	- MyDelegate d = obj.MyMethod;								// Assign the reference of the method to the newly created 
	// now I can pass it to a function or invoke it 
	
	- [ Multicasting ]
		- Delegates support multicastin, which means you can combine multiple methods into a single delegate
		d += obj.someOtherMethod
		d();
		
	[ Delegates Built-In ]
	
		- [ Func ] 
			- Represents a function that returns value and takes values		T1 <= T2, T3, ...
			- Func<int, int, int> add = (a,b) => a+b;	int result = add(3,5);
			
		- [ Action ]
			- Represents a method returns void and takes parameters		void <= T1, T2, ...
			- Action<string,string> print = (a,b) => Console.WriteLine(a+b);
			
		- [ Predicate ]
			- Represents a method return boolean and takes parameters		bool <= T1
			- Predicate<int> isbigger = (a) => a <= 6;	isbigger(3);		// Takes only one argument
                  
          [Anonymous delegate]
                    - A reference who have no name its reference not stored in the stack
                    - prin(delegate (int num) {return num>5})       // one use only, when we need a function just for one time, we don't create it
                    - Anonymous is not a better use instead we use Lambda Expression
                    - print(delegate (int num) { return num>5 })                   =>                  print(num => num > 5)
			
-------------------------------------------------- [ Event ] --------------------------------------------------
	- [ Observer design Pattern ]
                    - Simulating the Event Concept with that
                    
		- Publisher (Subject)
			- This is the entity that holds the information, notifies observers(listeners) about changes [WebSite, News]
		
		- Listeners (Observer)
			- These are the entities interested in being notified when the publisher changes [Users]
		
		- Subscription
			- This is the mechanism that connects the publisher and the listeners
          
          - There are issues using delegates
                    - assign delegate to null remove all the methods 
                    - any one can call it and it must be public so let the listeners subscibe
                    - Listener can assign more that one method
                    
          - To solve these 
                    - we have to disallow the listener to control the publisher => we use 'event' keyword
                    - by using event we can only use -= and +=. We can't use = so we can't assign null to it
          
          - [ Event Accessor ]
		- [ add ]		=> 	myEvent += value;
		- [ remove ]	=> 	myEvent -= value;
		-  public event EventHandler MyEvent			// EventHandler is a Delegate 
		   {
		       add { _myEvent += value; }
		       remove { _myEvent -= value; }
		   }
		   
-------------------------------------------------- [ Yield Return ] --------------------------------------------------
	
	- Is used in an iterator block to produce a sequence of avlue lazily
	- Iterator blocks are methods or properties that contain one or more Yield statements
	
	static IEnumerable<int> GenerateNumbers(){
		for (int i = 1; i<= 5; i++)
		{
			yield return i;		// multiple return executed by iterating using for each to that function
		}
	}
	IEnumerable<int> list = GenerateNumbers();	// The iterator method is called but it doesn't execute the entire method at once
	- the method starts executing until it reaches the yield retun statement 
	- the value specified after yield return is produced to the calling code 
	- the method is paused and the control returns to the calling code with the produced value 
	- the next time the iterator method is called, it resumes execution from where it left off continuing until the next yield retun or the end of the method
	- this lazy evaluation allows you to efficiently work with large seuences of data without loading all the data into memory at once

-------------------------------------------------- [ IQueryable & IEnumerable ] --------------------------------------------------
	
	// GetPeople returns list of Person objects

	+------------------------------------------------------------------------------------------+
	|// in [IEnumerable] the condition'x.age < 30' will be executed in the client side         |
	|// means that it will retrieve the data here then execute the condition                   |
	|IEnumerable<Person> enumerable = repository.GetPeopleIEnumerable().Where(x => x.Age < 30);|
	|------------------------------------------------------------------------------------------|
	|// In [IQueryable] the condition 'x.age < 30' will be executed in the server side  	 |
	|// means that it will execute the condition on server before getting the data here        |
          |IQueryable<Person>  queryable  = repository.GetPeopleIQueryable().Where (x => x.Age < 30);|
	+------------------------------------------------------------------------------------------+
	
	- enumerable and queryable will store the expression tree and will be defferred until we iterate over it or 
	- explicitly trigger the the execution by calling these methods [ .ToList() | .ToArray ]

-------------------------------------------------- [ Extension Method ] --------------------------------------------------
	- A feature in C# that allows you to add new methods to existing types without modifying them
	- Are defined in static classes and are marked with 'this' keyword before the first parameter, indicating the type that the method extends
		public static class PersonExtension{			// Rule#1 Class Must be static because it is a functionality class
			public static void Show(this Person data){	// Rule#2 Function Must be static to use it directly
								// Rule#3 First Parameter must start with 'this' then the [Class Name]
				Console.WriteLine(data.Name);
			}
		}
		// In Program 
		Person person = new Person(0, "Abdulrahman");
		       person.Show();	// Use the extension method
		       
-------------------------------------------------- [ LinQ ] --------------------------------------------------
	
	- [ Language Integrated Query ] --------------------------------------------------
		- Came after ADO, but ADO more speed than LinQ, Used in Banks
		- We can deal with Two Primary Syntax [ Method Syntax ] & [ Query Syntax ]	// Built-in Extension Methods
		- LinQ is designed to provide a unified way of querying different type of data sources using a consistent syntax
		- It enables developers to write qureies directly in their programming language instead of using SQL or other query language seprately
	
	- [ LinQ Types ] --------------------------------------------------	
		
		1- [ LinQ to Object ] 
			-- Data Source => [ Memory Collections ]
			-- Most Common Type of LinQ query
			-- It allow you to Query in memory collections [ Arrays, List, Dictionaries ] with the LinQ operators
			-- @ var nums = new List<int> {1,2,3,4,5,6}; @ var q = nums.Where(n => n < 3);	// 
			-- then we use foreach to use it
			-- Use Case: In-memory data manipulation

		2- [ LinQ to XML ] 
			-- Data Source => [ XML Data ]
			-- Manipulate XML data using [XElement] & [XDocument] Classes
			-- we can perform operations like filtering, projecting and sorting 
			-- @ XDocument xmlDoc = XDocument.Load("fileName.xml");	
			-- @ var q = from element in xmlDoc.Descendants("Person") where (string)element.Attribute("gender") == "male" select element;
			-- Use Case: Manipulating XML data

		3- [ LinQ to SQL ]	// Not Used any more, why shoule I work with SQL Only 
			-- Data Source => [ SQL Database ] 
			-- Create LinQ Queries that translate into SQL Queries
			-- Providing strongly-typed approach to database access
			-- @ var db = new DataContext("connectionString");
			-- @ q = from customer in db.Customers where custromer.City == "NewYork" select customer;
			-- Use Case: Strongly-typed approach to database access

		4- [ LinQ to Entity ] 
			-- Similar to LinQ to SQL
			-- query databases using Entity Framework
			-- A more versatile and feature-rich ORM (Object-Relational Mapping) Framework
			-- @ using (var context = new MyDbContext())
			-- @ {var query = from product in context.Products where product.Category == "Electronics" select product;}
			-- Use Case: Similar to LinQ to SQL but more versatile and feature-rich

		5- [ LinQ to DataSet ]	// ef	
			-- Data Source => [ ADO.NET DataSet ]	
			-- which is a collection of zero or more tables represented by DataTable objects
			-- @ var dataSet = new DataSet();
			-- @ dataTable = dataSet.Tables["TableName"];
			-- @ var q = from row in dataTabel.AsEnumerable() where (int)row["Age"] > 30 select row;
			-- Use Case: Disconnected data, data retrieved from database and stored in the memory

		6- [ LinQ to Objects with parallelism ]
			-- Data Source => [ Memory Collections ] 
			-- Use PLinQ to perform LinQ Queries on in-memory collections in parallel
			-- which takes advantage of multi-coreprocessors to speed up query execution
			-- @ var nums = Enumerable.Range(1,100000);
			-- @ var q = numbers.AsParallel().Where(n=> n % 2 == 0);
			-- Use Case: Performing LinQ queries in-memory collections in parallel to take advantage of multi-core processors
	
	- [Syntax] --------------------------------------------------
		- [ Method Syntax ]
			- We use Extension methods provided by the System.LinQ ( Which designed to chained together )
			- Fluent Interface 		// Offers a more fluent and method-chaining approach
			- Lambda Expressions	// We use it for defining the Criteria for filtering, Projecting, ordering and other query operations
			- IQuerable<object> q = collection.Where(n=> n< 2).OrderBy(n=> n.Name).Select(n=> n.Name);     
						// The Output for the Where is input for the next chain
						// We Could use anonymous object to return multiple value
		- [ Query Syntax ]
			- SQL-like Syntax, we use SQL Queries
			- More preferred for comples queries
			- Compiler Translation // Under the hood, the C# compiler translates query expressions into method syntax, so the two styles are are equivalent
			- var q = from n in collection where n < 2 order by n.Name select n.Name;
	
	- [ LinQ Providers ] --------------------------------------------------
		- LinQ relies on providers to translate the LinQ queries into a format that the underlying data source can unerstand
		- Providers exist for various data sources such as LinQ to SQL for relational databases and LinQ to XML for XML
	
	- [ Standard Query Operators ] --------------------------------------------------

		1- [ Projection Operators ]
			- [ Where ]           	Filters elements based on a specified condition
			- [ OfType ]          	Filters elements of a specific type from a collection
	
		2- [ Transformation Operators ]	
			- [ Select ]          	Projects each element into a new form or type
			- [ SelectMany ]      	Projects each element of a collection to an IEnumerable and flattens the resulting sequence into one sequence
	
		3- [ Sorting Operators ]	
			- [ OrderBy ]         	Sorts elements in ascending order based on a key
			- [ OrderByDescending]	Sorts elements in descending order based on a key
			- [ ThenBy ]          	Performs a secondary sort on elements that have the same key
			- [ ThenByDescending ]	Performs a secondary descending sort on elements that have the same key
	
		4- [ Aggregation Operators ]		// All Data loaded to calculate it					
			- [ Count ]           	Returns the number of elements in a collection
			- [ Sum ]             	Computes the sum of numeric elements in a collection
			- [ Average ]         	Computes the average of numeric elements in a collection
			- [ Min ]             	Returns the minimum element in a collection
			- [ Max ]             	Returns the maximum element in a collection
			- [ Aggregate ]       	Applies an accumulator function to the elements in a collection
	
		5- [ Quantifier Operators ]	
			- [ Any ]             	Determines if any elements in a collection satisfy a specified condition
			- [ All ]             	Determines if all elements in a collection satisfy a specified condition
	
		6- [ Element Operators ]	
			- [ First ]           	Returns the first element that satisfies a specified condition
			- [ FirstOrDefault ]  	Returns the first element that satisfies a specified condition or a default value if no elements match
			- [ Single ]          	Returns the only element that satisfies a specified condition
			- [ SingleOrDefault ] 	Returns the only element that satisfies a specified condition or a default value if no elements match
	
		7- [ Set Operators ]	
			- [ Distinct ]        	Returns distinct elements from a collection
			- [ Union ]           	Returns the union of two collections
			- [ Intersect ]       	Returns the intersection of two collections
			- [ Except ]          	Returns elements that are in the first collection but not in the second collection
	
		8- [ Partitioning Operators ]	
			- [ Take ]            	Returns a specified number of elements from the start of a collection
			- [ Skip ]            	Bypasses a specified number of elements from the start of a collection
			- [ TakeWhile ]       	Returns elements from a collection as long as a specified condition is true
			- [ SkipWhile ]       	Bypasses elements from a collection as long as a specified condition is true

	- [ LinQ to Objects ] --------------------------------------------------
		- LinQ can be used with any collection that implements the IEnumerable<T> or IQueryable<T>
		- It provides a way to query in-memory collections like arrays, list, dictionaries, etc
		
	- [ LinQ to SQL & Entities ] --------------------------------------------------
		- LinQ can be used to query databases using LinQ to SQL or LinQ to Entities
		- LinQ to SQL is used for querying SQL Server databases
		- LinQ to Entities is used for querying Entity Framework data models

	- [ Deferred Execution ] --------------------------------------------------
		- LinQ Queries are lazily executed, meaning that the query is not executed until the result is actually needed
			- IEnumerable<Person> list = plist.list;				// Eager Execution, no LinQ Query used 			
			- IEnumerable<Person> list = plist.list.Where(person => person.age < 25);	// Deferred Execution, LinQ Query used, list will store the expression tree and the query will be executed when iterate over it 
			- IQueryable<Person>  list = plist.list.AsQueryable().Where(p=>p.age<25);	// Deferred Execution, the filtering will done in the server side 
		- This allows for more efficient querying, especially when dealing with large datasets
	
	- [ Anonymous Types ] --------------------------------------------------
		- LinQ often makes use of anonymous types to project the result of a query into a new type on the fly
			- var result = from item in collection select new {item.Name, item.Property};	
				// 'select' part is used for project the data
				// 'new' is used to create new instance of an anonymous object to project it
	
	- [ Lambda Exressions ] --------------------------------------------------
		- Used in LinQ to define inline functions for filtering, ordering, and projecting
			- var query = collection.Where(item=> itme.Property > 10).OrderBy(item => item.Name);
		
	- [ Integration with Language Features ] --------------------------------------------------
		- LinQ integrates seamlessly with other language  features such as lambda expressions, extension methods, and anonymous types
	
	- [ Error Handling ] --------------------------------------------------
		- LinQ provides a concise and readable way to handle errors in queries using the try-catch block
			try{
				var result = from item in collection select item.Property / item.Divisor;
			}catch (DivisionByZeroException ex){
				// Handl the exception
			}

-------------------------------------------------- [ Dependency Injection ] --------------------------------------------------			
	- Is a design pattern and a technique in software development where the components of a system are provided with their dependencies rather that creating them internally
	- Instead of a component creating its dependencies, the dependencies are "Injected" into the component from the outside
	- Types of injection are
		- Constructor Injection
		- Method Injection
		- Property Injection
		- 
	
			
-------------------------------------------------- [ Entity Framework ] --------------------------------------------------
	- Entity Framework Core (EF Core)
		- Uses an Entity Data Model to represent the conceptual model of the data
		- This Models Include Entities, represents tables in the database, associations (representing relationships between entities) and mapping
		- This is the version of Entity Framework designed to work with .NET Core
	
	- Code-First / Model-First approach
		- [Code-First]
			Define C# classes; EF Core generates the database.

		- [Model-First]
			- Design the database schema; EF Core generates C# classes.
			
	- DbContext
		- Represents a database session, includes DbSet<T> for entities.
		
	- Entity Types
		- Classes representing database tables, with properties mapping to columns.
	
	- Configuration
		- Classes representing database tables, with properties mapping to columns.
	
	- LinQ Queries
		- Use LINQ for complex queries against entity types.
		
	- Database Migrations
		- EF Core Includes a migration system that enables you to evolve the database schema as your application evelves
		- Migration can be generated and applied to update the database
	
	- Database Providers
		- Supports various database providres (SQL Server, SQLite, ...)
		
	- Async Operations
		- Supports asynchronous query and save operations for scalabitily
		
	- Dependency Injection
		- Integrated with .NET Core's dependency injection system
		
	- Logging and Interception
		- Provides logging for debugging, allows interception of database operations
	